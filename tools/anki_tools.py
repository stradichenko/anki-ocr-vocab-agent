"""Anki-related tools for vocabulary processing."""

import yaml
import csv
import re
import os
from smolagents import tool

@tool
def yaml_to_anki(yaml_content: str) -> str:
    """
    Convert YAML vocabulary entries into an Anki-ready CSV file.
    
    Args:
        yaml_content: The pure YAML generated by the model
        
    Returns:
        Path to the generated anki CSV file
    """
    OUTPUT_FILE = "anki_cards.csv"
    
    def is_proper_name(word: str) -> bool:
        return bool(re.match(r'^[A-Z]', str(word).strip()))
    
    if not isinstance(yaml_content, str):
        raise RuntimeError("yaml_content must be a string.")

    # Clean up the YAML content
    yaml_content = yaml_content.strip()
    
    # Remove markdown fences if present
    if yaml_content.startswith("```") and yaml_content.endswith("```"):
        yaml_content = yaml_content[3:-3].strip()
    elif yaml_content.startswith("```yaml"):
        yaml_content = yaml_content[7:].strip()
        if yaml_content.endswith("```"):
            yaml_content = yaml_content[:-3].strip()
    
    # Handle truncated or malformed YAML
    if yaml_content.count("'") % 2 != 0:
        print("‚ö†Ô∏è Warning: Odd number of single quotes detected, attempting to fix...")
        # Try to balance quotes by adding a closing quote at the end
        yaml_content += "'"
    
    if yaml_content.count('"') % 2 != 0:
        print("‚ö†Ô∏è Warning: Odd number of double quotes detected, attempting to fix...")
        yaml_content += '"'

    try:
        data = yaml.safe_load(yaml_content)
    except yaml.YAMLError as e:
        print(f"‚ùå YAML parsing failed: {e}")
        print(f"üìù Problematic YAML content (first 500 chars): {yaml_content[:500]}")
        
        # Try to salvage partial content by finding complete entries
        lines = yaml_content.split('\n')
        salvaged_entries = []
        current_entry = {}
        
        for line in lines:
            line = line.strip()
            if line.startswith('- word:'):
                if current_entry:
                    salvaged_entries.append(current_entry)
                current_entry = {'word': line.split(':', 1)[1].strip()}
            elif line.startswith('back:') and current_entry:
                current_entry['back'] = line.split(':', 1)[1].strip().strip("'\"")
            elif line.startswith('tags:') and current_entry:
                current_entry['tags'] = line.split(':', 1)[1].strip().strip("[]")
        
        if current_entry:
            salvaged_entries.append(current_entry)
        
        if salvaged_entries:
            print(f"üîß Salvaged {len(salvaged_entries)} entries from malformed YAML")
            data = salvaged_entries
        else:
            print("‚ùå Could not salvage any entries, creating empty dataset")
            data = []

    if isinstance(data, dict):
        data = [data]
    if not isinstance(data, list):
        print("‚ö†Ô∏è Warning: Parsed YAML is not a list, converting to list")
        data = []

    seen = set()
    cleaned_data = []
    
    for entry in data:
        if not isinstance(entry, dict):
            continue
            
        word = str(entry.get("word", "")).strip()
        back = str(entry.get("back", "")).strip()
        tags = str(entry.get("tags", "")).strip()

        # Clean up fields
        word = word.strip("'\"")
        back = back.strip("'\"")
        tags = tags.strip("'\"[]")

        if not word or word.lower() in ['word', 'example', 'test']:
            continue

        if not is_proper_name(word):
            word = word.lower()

        if word.lower() in seen:
            continue
        seen.add(word.lower())

        cleaned_data.append([word, back, tags])

    # Append to existing CSV if it exists, otherwise create new
    mode = 'a' if os.path.exists(OUTPUT_FILE) else 'w'
    write_header = not os.path.exists(OUTPUT_FILE)
    
    with open(OUTPUT_FILE, mode, encoding="utf-8", newline="") as f:
        writer = csv.writer(f)
        if write_header:
            writer.writerow(["Word", "Back", "Tags"])
        writer.writerows(cleaned_data)
    
    print(f"‚úÖ Successfully added {len(cleaned_data)} vocabulary entries to CSV")
    return os.path.abspath(OUTPUT_FILE)
