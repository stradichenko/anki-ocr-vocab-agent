#!/usr/bin/env python3
"""
vocab_ocr_agent.py

OCR a vocabulary image with a local Ollama Qwen2.5-VL model (via LiteLLMModel)
and convert the extracted YAML into an Anki-ready CSV (anki_cards.csv).

Notes:
 - Requires smolagents with LiteLLM support (pip install "smolagents[litellm]" pyyaml).
 - Ollama server should be running (default http://127.0.0.1:11434).
"""

import yaml
import csv
import re
import os
import sys
import base64
import traceback
from smolagents import Tool, CodeAgent, LiteLLMModel

# ========== 1. YAML ‚Üí Anki Conversion Tool ==========
class YamlToAnkiTool(Tool):
    name = "yaml_to_anki"
    description = "Convert YAML vocabulary entries into an Anki-ready CSV file."

    inputs = {
        "yaml_content": {
            "type": "string",
            "description": "The pure YAML generated by the model."
        }
    }
    output_type = "string"

    OUTPUT_FILE = "anki_cards.csv"

    def is_proper_name(self, word: str) -> bool:
        return bool(re.match(r'^[A-Z]', str(word).strip()))

    def forward(self, yaml_content: str) -> str:
        if not isinstance(yaml_content, str):
            raise RuntimeError("yaml_content must be a string.")

        yaml_content = yaml_content.strip()
        if yaml_content.startswith("```") and yaml_content.endswith("```"):
            yaml_content = yaml_content[3:-3].strip()

        try:
            data = yaml.safe_load(yaml_content)
        except yaml.YAMLError as e:
            raise RuntimeError(f"‚ùå YAML error: {e}")

        if isinstance(data, dict):
            data = [data]
        if not isinstance(data, list):
            raise RuntimeError("‚ùå Parsed YAML is not a list or dict of entries.")

        seen = set()
        cleaned_data = []
        for entry in data:
            if not isinstance(entry, dict):
                continue
            word = str(entry.get("word", "")).strip()
            back = str(entry.get("back", "")).strip()
            tags = str(entry.get("tags", "")).strip()

            if not word:
                continue

            if not self.is_proper_name(word):
                word = word.lower()

            if word.lower() in seen:
                continue
            seen.add(word.lower())

            cleaned_data.append([word, back, tags])

        with open(self.OUTPUT_FILE, "w", encoding="utf-8", newline="") as f:
            writer = csv.writer(f)
            writer.writerow(["Word", "Back", "Tags"])
            writer.writerows(cleaned_data)

        return os.path.abspath(self.OUTPUT_FILE)


# ========== 1b. File Access Tools (robust) ==========
class FileReader(Tool):
    name = "file_reader"
    description = "Read the contents of a local file. Returns text or BINARY_BASE64::<b64> for binary files."

    inputs = {
        "path": {
            "type": "string",
            "description": "Path to the file to read."
        }
    }
    output_type = "string"

    def forward(self, path: str) -> str:
        if not isinstance(path, str):
            raise RuntimeError("path must be a string.")
        if not os.path.exists(path):
            raise FileNotFoundError(f"File not found: {path}")

        # Try to read as UTF-8 text first
        try:
            with open(path, "r", encoding="utf-8") as f:
                return f.read()
        except UnicodeDecodeError:
            # Binary file: return base64 encoded content with a prefix so callers know
            with open(path, "rb") as bf:
                b = bf.read()
            b64 = base64.b64encode(b).decode("ascii")
            return f"BINARY_BASE64::{b64}"
        except Exception as e:
            raise RuntimeError(f"Error reading file {path}: {e}")


class FileWriter(Tool):
    name = "file_writer"
    description = "Write content to a local file. Accepts plain text or BINARY_BASE64::<b64> to write binary."

    inputs = {
        "path": {
            "type": "string",
            "description": "Path where the content should be written."
        },
        "content": {
            "type": "string",
            "description": "Content to write into the file. If writing binary, prefix with 'BINARY_BASE64::'."
        }
    }
    output_type = "string"

    def forward(self, path: str, content: str) -> str:
        if not isinstance(path, str) or not isinstance(content, str):
            raise RuntimeError("path and content must be strings.")
        # create directories if needed
        os.makedirs(os.path.dirname(path) or ".", exist_ok=True)

        if content.startswith("BINARY_BASE64::"):
            b64 = content.split("BINARY_BASE64::", 1)[1]
            try:
                data = base64.b64decode(b64)
            except Exception as e:
                raise RuntimeError(f"Invalid base64 content: {e}")
            with open(path, "wb") as bf:
                bf.write(data)
        else:
            with open(path, "w", encoding="utf-8") as f:
                f.write(content)
        return os.path.abspath(path)


# ========== 2. OCR Extraction Prompt ==========
OCR_PROMPT = """
I will upload images to input/ the images contain vocabulary words with their meanings and example sentences.
You are an expert at reading vocabulary from images. You can see the image content directly as a Vision Language Model.

CRITICAL INSTRUCTIONS:
1. DO NOT import any Python libraries - they are not available nor allowed. As a VLM you can already see the image. 
2. DO NOT try to simulate or fake content - extract REAL vocabulary from the actual image
3. Look carefully at the image and identify vocabulary words, definitions, and examples
4. After extracting vocabulary, call yaml_to_anki tool with properly formatted YAML

Your tasks are:
1. For each vocabulary entry, extract:
   - word: the vocabulary word (lowercase unless it is a personal/proper name, in which case keep original capitalization). If the word is a verb, replace it with the infinitive form.
   - back:
       * Start with the meaning.
       * If the word has a noun alternative add an explanation of the noun.
       * Then add 2‚Äì3 examples, all enclosed in a single bracket ("example sentence", "...").
         Examples should be realistic and varied in structure.
   - tags: grammatical category such as "noun", "verb", "adjective", "adverb", etc (could be many tags)

2. If any field is missing, try to infer or improve it:
   - If examples are missing or too few, create new ones (ensure at least 2‚Äì3 examples per word).
   - If the meaning can be improved for clarity, do so.
   - If the grammatical tag is unclear, deduce it from the word and context.
   - If the word is a verb, include its infinitive in the back field.

3. Output pure YAML exactly in the requested format (no extra text). Wrap it between triple backticks.

    Format as valid YAML list (use dashes, NO document separators ---):
    ```yaml
    - word: example
    back: 'Definition here ("example sentence 1", "example sentence 2")'
    tags: verb
    - word: another
    back: 'Another definition ("example A", "example B")'
    tags: noun
    ```
"""

# ========== 3. Model Setup ==========
model = LiteLLMModel(
    model_id="ollama_chat/qwen2.5vl:latest",
    api_base="http://127.0.0.1:11434",
    num_ctx=8192,
)


# ========== 4. Helper to show tool names ==========
def safe_tool_name(t):
    try:
        if isinstance(t, str):
            return t
        return getattr(t, "name", repr(t))
    except Exception:
        return repr(t)


# ========== 5. Create tool instances and run comprehensive self-tests ==========
yaml_tool = YamlToAnkiTool()
file_reader_tool = FileReader()
file_writer_tool = FileWriter()
tools = [yaml_tool, file_reader_tool, file_writer_tool]

print("Local tool instances:", [safe_tool_name(t) for t in tools])

def run_comprehensive_self_test():
    """
    Comprehensive self-test suite to verify all components are working.
    Tests file I/O, directory scanning, image detection, and VLM capabilities.
    """
    print("\n" + "="*80)
    print("üîß COMPREHENSIVE SELF-TEST SUITE")
    print("="*80)
    
    # Test 1: Basic file operations
    print("\nüìÅ TEST 1: File Operations")
    print("-" * 40)
    
    test_path = "agent_self_test.txt"
    test_content = "agent self-test: comprehensive check\nLine 2: UTF-8 encoding test: √°√©√≠√≥√∫ √±\nLine 3: timestamp=" + str(os.path.getmtime(__file__) if os.path.exists(__file__) else "unknown")
    
    try:
        print("‚Üí Writing test file via FileWriter...")
        abs_written = file_writer_tool.forward(test_path, test_content)
        print(f"   ‚úÖ Wrote file to: {abs_written}")
        print(f"   üìè File size: {os.path.getsize(abs_written)} bytes")
        
        print("‚Üí Reading test file via FileReader...")
        read_back = file_reader_tool.forward(test_path)
        print(f"   üìñ Read {len(read_back)} characters")
        print(f"   üìù Content preview: {repr(read_back[:100])}{'...' if len(read_back) > 100 else ''}")
        
        if read_back == test_content:
            print("   ‚úÖ File write/read integrity: PASSED")
        else:
            print("   ‚ùå File write/read integrity: FAILED")
            print(f"   Expected: {repr(test_content[:50])}...")
            print(f"   Got:      {repr(read_back[:50])}...")
    except Exception as e:
        print(f"   ‚ùå File operations error: {e}")
        traceback.print_exc()
    
    # Test 2: Directory scanning and file discovery
    print("\nüìÇ TEST 2: Directory and File Discovery")
    print("-" * 40)
    
    try:
        # Scan current directory
        current_files = [f for f in os.listdir('.') if os.path.isfile(f)]
        print(f"‚Üí Current directory contains {len(current_files)} files:")
        for f in sorted(current_files)[:10]:  # Show first 10
            size = os.path.getsize(f)
            print(f"   üìÑ {f} ({size} bytes)")
        if len(current_files) > 10:
            print(f"   ... and {len(current_files) - 10} more files")
        
        # Look for input directory and images
        input_dir = "input"
        if os.path.exists(input_dir) and os.path.isdir(input_dir):
            print(f"‚Üí Input directory '{input_dir}' found")
            input_files = os.listdir(input_dir)
            image_files = [f for f in input_files if f.lower().endswith(('.png', '.jpg', '.jpeg', '.gif', '.bmp', '.webp'))]
            print(f"   üìÅ Contains {len(input_files)} total files")
            print(f"   üñºÔ∏è  Found {len(image_files)} image files:")
            for img in image_files:
                img_path = os.path.join(input_dir, img)
                size = os.path.getsize(img_path)
                print(f"      üñºÔ∏è  {img} ({size} bytes, {size/1024:.1f} KB)")
        else:
            print(f"‚Üí Input directory '{input_dir}' not found")
            
    except Exception as e:
        print(f"   ‚ùå Directory scanning error: {e}")
    
    # Test 3: Binary file handling
    print("\nüîß TEST 3: Binary File Handling")
    print("-" * 40)
    
    try:
        # Create a small binary test file
        binary_data = b'\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01'  # PNG header-like
        binary_path = "test_binary.bin"
        
        print("‚Üí Creating test binary file...")
        with open(binary_path, "wb") as bf:
            bf.write(binary_data)
        print(f"   ‚úÖ Created {binary_path} with {len(binary_data)} bytes")
        
        print("‚Üí Reading binary file via FileReader...")
        binary_result = file_reader_tool.forward(binary_path)
        if binary_result.startswith("BINARY_BASE64::"):
            decoded = base64.b64decode(binary_result.split("::", 1)[1])
            if decoded == binary_data:
                print("   ‚úÖ Binary file read/decode: PASSED")
            else:
                print("   ‚ùå Binary file decode mismatch")
        else:
            print("   ‚ùå Binary file not detected as binary")
            
        # Clean up
        os.remove(binary_path)
        print("   üóëÔ∏è  Cleaned up test binary file")
        
    except Exception as e:
        print(f"   ‚ùå Binary file test error: {e}")
    
    # Test 4: YAML processing
    print("\nüìã TEST 4: YAML Processing")
    print("-" * 40)
    
    try:
        test_yaml = """- word: test
  back: 'A trial or examination ("I took a test", "This is a test case", "Testing is important")'
  tags: noun
- word: example
  back: 'A representative instance ("For example", "This is an example", "Set a good example")'
  tags: noun"""
        
        print("‚Üí Testing YAML to Anki conversion...")
        print(f"   üìù Test YAML ({len(test_yaml)} chars):")
        print("   " + "\n   ".join(test_yaml.split('\n')[:4]) + "...")
        
        csv_path = yaml_tool.forward(test_yaml)
        print(f"   ‚úÖ Generated CSV: {csv_path}")
        
        if os.path.exists(csv_path):
            with open(csv_path, 'r', encoding='utf-8') as f:
                csv_content = f.read()
            lines = csv_content.strip().split('\n')
            print(f"   üìä CSV contains {len(lines)} lines (including header)")
            print(f"   üìÑ CSV preview: {lines[0] if lines else 'empty'}")
            if len(lines) > 1:
                print(f"                   {lines[1][:60]}{'...' if len(lines[1]) > 60 else ''}")
        
    except Exception as e:
        print(f"   ‚ùå YAML processing error: {e}")
    
    # Test 5: Model connectivity
    print("\nü§ñ TEST 5: Model Connectivity")
    print("-" * 40)
    
    try:
        print(f"‚Üí Model configuration:")
        print(f"   üîó Model ID: {model.model_id}")
        print(f"   üåê API Base: {model.api_base}")
        print(f"   üìä Context: {getattr(model, 'num_ctx', 'unknown')}")
        
        # Try a simple test query (without image)
        simple_query = "What is 2+2? Answer with just the number."
        print("‚Üí Testing basic model response...")
        
        # Create a minimal agent for testing
        test_agent = CodeAgent(
            tools=[],  # No tools for this test
            model=model,
            max_steps=1,
            verbosity_level=0,
            add_base_tools=False
        )
        
        result = test_agent.run(simple_query)
        print(f"   ‚úÖ Model responded: {str(result)[:100]}{'...' if len(str(result)) > 100 else ''}")
        
    except Exception as e:
        print(f"   ‚ùå Model connectivity error: {e}")
        print("   ‚ö†Ô∏è  This might be normal if Ollama server is not running")
    
    # Test 6: Image file validation
    print("\nüñºÔ∏è  TEST 6: Image File Validation")
    print("-" * 40)
    
    test_image_path = "input/vocabulary_page.png"
    if os.path.exists(test_image_path):
        try:
            stat = os.stat(test_image_path)
            print(f"‚Üí Target image file found: {test_image_path}")
            print(f"   üìè Size: {stat.st_size} bytes ({stat.st_size/1024:.1f} KB)")
            print(f"   üìÖ Modified: {os.path.getmtime(test_image_path)}")
            
            # Try to read as binary
            with open(test_image_path, 'rb') as f:
                header = f.read(16)
            print(f"   üîç File header: {header.hex()[:32]}...")
            
            # Check if it looks like a valid image
            if header.startswith(b'\x89PNG'):
                print("   ‚úÖ Detected as PNG image")
            elif header.startswith(b'\xff\xd8\xff'):
                print("   ‚úÖ Detected as JPEG image")
            elif header.startswith(b'GIF8'):
                print("   ‚úÖ Detected as GIF image")
            elif header.startswith(b'RIFF') and b'WEBP' in header:
                print("   ‚úÖ Detected as WebP image")
            else:
                print(f"   ‚ö†Ô∏è  Unknown image format (header: {header[:8].hex()})")
                
        except Exception as e:
            print(f"   ‚ùå Image validation error: {e}")
    else:
        print(f"‚Üí Target image not found: {test_image_path}")
        print("   ‚ö†Ô∏è  You may need to place a vocabulary image at this path")
    
    print("\n" + "="*80)
    print("üèÅ SELF-TEST COMPLETE")
    print("="*80)

# Run the comprehensive self-test
run_comprehensive_self_test()


# ========== 6. Build Agent ==========
agent = CodeAgent(
    tools=tools,
    model=model,
    max_steps=3,
    verbosity_level=1,
    add_base_tools=False
)

print("Agent created. Tools reported by agent (best-effort):")
try:
    print([safe_tool_name(t) for t in getattr(agent, "tools", [])])
except Exception:
    try:
        print("Raw agent.tools:", agent.tools)
    except Exception as e:
        print("Could not display agent.tools:", e)
        traceback.print_exc()


# ========== 7. Run Agent on an Image ==========
def process_vocab_image(image_path: str):
    """
    Important: Do NOT attempt to open the image file as UTF-8 text in Python
    (that will raise UnicodeDecodeError). Instead:
      - Prefer passing the image *path* in the prompt and let the model/tool call file_reader,
        OR attach the image binary to the model request if your client supports that.
    """
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found: {image_path}")

    query = (
        f"{OCR_PROMPT}\n"
        f"Here is the vocabulary image: {image_path}\n"
        f"Please produce PURE YAML (only) following the spec above, "
        f"then call the tool `yaml_to_anki` with the YAML content."
    )

    try:
        result = agent.run(query)
    except Exception as e:
        print("Agent run raised an exception:", e)
        traceback.print_exc()
        raise
    print("Agent run returned:", result)
    print("If parsing succeeded you should have anki_cards.csv in the current directory.")
    return result


if __name__ == "__main__":
    vocab_image = sys.argv[1] if len(sys.argv) > 1 else "input/vocabulary_page.png"
    print("Processing image:", vocab_image)
    process_vocab_image(vocab_image)
